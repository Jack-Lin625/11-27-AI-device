<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å…‰ç·šåˆ¤å®šï¼šAI é›¢ç·šæ´»å‹•æ¨è–¦</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.14.0/dist/tf.min.js"></script>

    <style>
        /* åŸºç¤æ¨£å¼å’Œä½ˆå±€ (ä¿æŒæ‚¨åŸæœ‰çš„å…¨å±é¢¨æ ¼) */
        body { 
            margin: 0; padding: 0; background-color: #000; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
            overflow: hidden; display: flex; flex-direction: column; align-items: center; 
            justify-content: center; height: 100vh;
        }
        #cam-container { 
            position: relative; width: 100%; height: 100%; display: flex; 
            justify-content: center; align-items: center; background: #111; 
        }
        video { 
            position: absolute; width: 100%; height: 100%; object-fit: cover; 
        }
        /* éš±è— Canvasï¼Œå› ç‚ºæˆ‘å€‘ä¸å†ç¹ªè£½æ–¹æ¡†ï¼Œåªç”¨æ–¼æŠ“å–å¹€åœ–åƒ */
        #canvas { display: none; } 

        /* ä»‹é¢è¦†è“‹å±¤ */
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 10; pointer-events: none; display: flex; flex-direction: column; 
            justify-content: space-between; padding: 20px; box-sizing: border-box; 
        }
        .status-bar { 
            background: rgba(0, 0, 0, 0.6); color: #00ffcc; padding: 10px 15px; 
            border-radius: 20px; font-size: 14px; backdrop-filter: blur(5px); 
            align-self: flex-start; pointer-events: auto; margin-top: 10px; line-height: 1.6; 
        }
        
        /* æ–°å¢åº•éƒ¨çµæœé¡¯ç¤ºå€å¡Š (æ›¿ä»£ç‰©ä»¶è¾¨è­˜çš„æ–¹æ¡†) */
        #result-display { 
            background: rgba(0, 0, 0, 0.7); color: white; padding: 20px; border-radius: 15px; 
            align-self: center; margin-bottom: 50px; width: 90%; max-width: 400px; 
            text-align: center; pointer-events: auto; 
        }
        #light-level { 
            font-size: 1.8em; font-weight: bold; color: #FFC107; margin-bottom: 5px; 
        }
        #activity-recommendation { 
            font-size: 1.1em; color: #B3E5FC; 
        }

        /* å•Ÿå‹•ç•«é¢ */
        #start-screen { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0, 0, 0, 0.85); z-index: 20; display: flex; 
            flex-direction: column; justify-content: center; align-items: center; 
            text-align: center; color: white; 
        }
        button { 
            background: #007aff; color: white; border: none; padding: 15px 40px; 
            font-size: 18px; border-radius: 30px; cursor: pointer; margin-top: 20px; 
            font-weight: bold; box-shadow: 0 4px 15px rgba(0,122,255,0.4); transition: transform 0.2s; 
        }
        button:active { transform: scale(0.95); }
        button:disabled { background: #555; color: #888; cursor: not-allowed; box-shadow: none; }
        .loader { 
            border: 4px solid #f3f3f3; border-top: 4px solid #00ffcc; border-radius: 50%; 
            width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 20px; 
            display: none; 
        }
        @keyframes spin { 
            0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } 
        }
    </style>
</head>
<body>

    <div id="cam-container">
        <video id="video" playsinline muted autoplay></video>
        <canvas id="canvas"></canvas>
    </div>

    <div id="ui-layer">
        <div class="status-bar" id="status">ç­‰å¾…å•Ÿå‹•...</div>
        
        <div id="result-display">
            <div id="light-level">å…‰ç·šç­‰ç´š</div>
            <div id="activity-recommendation">æ¨è–¦æ´»å‹•å°‡é¡¯ç¤ºåœ¨é€™è£¡</div>
        </div>
    </div>

    <div id="start-screen">
        <div class="loader" id="loader"></div>
        <h2 id="loading-text">å…‰ç·šåˆ¤å®šï¼šAI æ¨¡å‹æº–å‚™ä¸­</h2>
        <p id="info-text" style="font-size: 0.9em; color: #aaa; margin: 0 20px;">
            **ã€æ­¥é©Ÿ 1/2ã€‘** è«‹ä¿æŒç¶²è·¯é€£ç·šï¼Œæ­£åœ¨ä¸‹è¼‰ AI æ¨¡å‹ (ç´„ 4 MB)ã€‚<br>
            **ã€æ­¥é©Ÿ 2/2ã€‘** è¼‰å…¥å®Œæˆå¾Œï¼Œå³å¯åˆ‡æ›è‡³**é£›èˆªæ¨¡å¼**é€²è¡Œé›¢ç·šæ¨è«–ã€‚
        </p>
        <button id="btn-start" disabled>é–‹å§‹è¾¨è­˜ (è¼‰å…¥ä¸­)</button>
    </div>

    <script>
        // DOM å…ƒç´ 
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const btnStart = document.getElementById('btn-start');
        const statusText = document.getElementById('status');
        const startScreen = document.getElementById('start-screen');
        const loader = document.getElementById('loader');
        const loadingText = document.getElementById('loading-text');
        const infoText = document.getElementById('info-text');
        const lightLevelElement = document.getElementById('light-level');
        const recommendationElement = document.getElementById('activity-recommendation');

        let model = undefined;
        let animationFrameId = null;
        const MODEL_INPUT_SIZE = 224; 
        
        // æ´»å‹•æ¨è–¦å­—å…¸
        const ACTIVITIES = {
            'æ˜äº®æˆ¶å¤–/é«˜å…‰': { emoji: 'â˜€ï¸', level: 'æ˜äº®æˆ¶å¤–/é«˜å…‰', recommend: 'æ…¢è·‘ã€é¨å–®è»Šã€æˆ¶å¤–é‡é¤', color: '#FFD700' },
            'å……è¶³å®¤å…§/ä¸­å…‰': { emoji: 'ğŸ’¡', level: 'å……è¶³å®¤å…§/ä¸­å…‰', recommend: 'é–±è®€æ›¸ç±ã€è¦åŠƒæ¸…å–®ã€å­¸ç¿’æ–°æŠ€èƒ½', color: '#00ffcc' },
            'æ˜æš—å¤œæ™š/ä½å…‰': { emoji: 'ğŸŒ™', level: 'æ˜æš—å¤œæ™š/ä½å…‰', recommend: 'å†¥æƒ³æ”¾é¬†ã€è½è¼•éŸ³æ¨‚ã€æº–å‚™å°±å¯¢', color: '#8A2BE2' },
            'æœªçŸ¥ç’°å¢ƒ': { emoji: 'ğŸ¤”', level: 'ç„¡æ³•åˆ¤æ–·', recommend: 'è«‹èª¿æ•´é¡é ­è§’åº¦ï¼Œå°æº–ç’°å¢ƒå…‰ç·š', color: '#E91E63' }
        };

        window.onload = async () => {
            // **ã€é‡å°ç©ºç™½é æª¢æŸ¥ 1ã€‘**ï¼šæª¢æŸ¥ TensorFlow.js æ˜¯å¦å·²è¼‰å…¥ (é˜² CDN å¤±æ•—)
            if (typeof tf === 'undefined') {
                loadingText.textContent = "âŒ éŒ¯èª¤ï¼šTensorFlow.js æ ¸å¿ƒå‡½å¼åº«è¼‰å…¥å¤±æ•—ï¼";
                infoText.innerHTML = "è«‹æª¢æŸ¥æ‚¨çš„**ç¶²è·¯é€£ç·š**æˆ–æ‚¨çš„**æ‰‹æ©Ÿç€è¦½å™¨æ˜¯å¦æ”¯æ´ WebGL**ã€‚";
                return; 
            }

            btnStart.addEventListener('click', startAIInference);
            // ç”±æ–¼æ¨¡å‹è¼‰å…¥éœ€è¦æ™‚é–“ï¼Œå…ˆç¦ç”¨æŒ‰éˆ•
            btnStart.disabled = true;
            await loadModelAndSetupCamera();
        }

        async function loadModelAndSetupCamera() {
            loadingText.textContent = "å…‰ç·šåˆ¤å®šï¼šAI æ¨¡å‹æº–å‚™ä¸­";
            infoText.innerHTML = "ã€æ­¥é©Ÿ 1/2ã€‘è«‹ä¿æŒç¶²è·¯é€£ç·šï¼Œæ­£åœ¨ä¸‹è¼‰ AI æ¨¡å‹ (ç´„ 4 MB)...";
            loader.style.display = 'block';

            try {
                // A. è¼‰å…¥ MobileNetV3 åˆ†é¡æ¨¡å‹ (éœ€ç¶²è·¯)
                model = await tf.loadGraphModel(
                    'https://tfhub.dev/google/imagenet/mobilenet_v3_small_075_224/classification/5',
                    { fromTFHub: true }
                );
                
                // é ç†± AI æ ¸å¿ƒ
                tf.tidy(() => { model.predict(tf.zeros([1, MODEL_INPUT_SIZE, MODEL_INPUT_SIZE, 3])); });
                
                loadingText.textContent = "âœ… æ¨¡å‹è¼‰å…¥å®Œæˆï¼æ­£åœ¨å•Ÿå‹•ç›¸æ©Ÿ...";
                infoText.innerHTML = "ã€æ­¥é©Ÿ 2/2ã€‘è«‹å…è¨±ç›¸æ©Ÿæ¬Šé™ã€‚";
                
                // B. å•Ÿå‹•ç›¸æ©Ÿ
                const cameraSuccess = await setupCamera();
                if (!cameraSuccess) return; 

                loadingText.textContent = "âœ… ç›¸æ©Ÿå°±ç·’ï¼";
                infoText.innerHTML = "AI å·²æº–å‚™å¥½ **é›¢ç·šæ¨è«–**ã€‚è«‹é»æ“Šé–‹å§‹ï¼Œå³å¯åˆ‡æ›é£›èˆªæ¨¡å¼ã€‚";
                btnStart.disabled = false;
                btnStart.innerText = "ğŸš€ é–‹å§‹ AI åˆ¤æ–· (å¯é›¢ç·š)";

            } catch (error) {
                console.error('æ¨¡å‹è¼‰å…¥æˆ–åˆå§‹åŒ–å¤±æ•—:', error);
                
                // **ã€é‡å°ç©ºç™½é æª¢æŸ¥ 2ã€‘**ï¼šæ›´æ˜ç¢ºçš„ç¶²è·¯éŒ¯èª¤æç¤º
                loadingText.textContent = `âŒ æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼`;
                infoText.innerHTML = `è«‹æª¢æŸ¥æ‚¨çš„**ç¶²è·¯é€£ç·š**ï¼Œç¢ºä¿æ¨¡å‹æª”æ¡ˆèƒ½å¤ é¦–æ¬¡ä¸‹è¼‰ã€‚`;
                loader.style.display = 'none';
                btnStart.disabled = true; 
                btnStart.innerText = "ğŸš¨ è¼‰å…¥å¤±æ•— (éœ€é€£ç¶²)";
            }
        }

        async function setupCamera() {
            const constraints = {
                audio: false,
                video: { facingMode: 'environment', width: { ideal: 640 }, height: { ideal: 480 } }
            };
            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        resizeCanvas();
                        window.addEventListener('resize', resizeCanvas);
                        resolve(true);
                    };
                });
            } catch (e) {
                // **ã€é‡å°ç©ºç™½é æª¢æŸ¥ 3ã€‘**ï¼šç›¸æ©Ÿæ¬Šé™è¢«æ‹’çµ•çš„æ˜ç¢ºæç¤º
                loadingText.textContent = `âŒ ç›¸æ©Ÿæ¬Šé™è¢«æ‹’çµ•ï¼`;
                infoText.innerHTML = `è«‹å…è¨±ç€è¦½å™¨ä½¿ç”¨ç›¸æ©Ÿæ¬Šé™æ‰èƒ½é€²è¡Œå…‰ç·šåˆ¤å®šã€‚`;
                btnStart.disabled = true;
                return false;
            }
        }

        function resizeCanvas() {
            // è®“ Canvas å°ºå¯¸åŒ¹é…å½±ç‰‡çš„å¯¦éš›è§£æåº¦
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
        }

        function startAIInference() {
            if (animationFrameId) {
                // æš«åœé‚è¼¯
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                btnStart.textContent = 'â–¶ï¸ ç¹¼çºŒåˆ¤æ–·';
                statusText.textContent = 'â¸ AI åˆ¤æ–·å·²æš«åœã€‚';
                return;
            }

            // å•Ÿå‹•é‚è¼¯
            startScreen.style.display = 'none';
            statusText.textContent = 'ğŸš€ AI é‹ä½œä¸­ - On Device / é›¢ç·šæ¨¡å¼';
            btnStart.textContent = 'â¸ æš«åœåˆ¤æ–·';

            predictLoop();
        }

        async function predictLoop() {
            if (!model || video.readyState < 2) {
                animationFrameId = requestAnimationFrame(predictLoop);
                return;
            }

            // **æ ¸å¿ƒé›¢ç·šæ¨è«–**
            tf.tidy(() => {
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                const imageTensor = tf.browser.fromPixels(canvas)
                    .resizeNearestNeighbor([MODEL_INPUT_SIZE, MODEL_INPUT_SIZE])
                    .toFloat()
                    .div(255.0)
                    .expandDims();

                const prediction = model.predict(imageTensor);
                
                const topK = tf.topk(prediction, 1);
                const values = topK.values.dataSync();
                const indices = topK.indices.dataSync();

                const maxProb = values[0];
                const topIndex = indices[0];

                let lightResult;

                // æ ¹æ“š MobileNetV3 ç´¢å¼•æ¨¡æ“¬å…‰ç·šåˆ¤æ–·é‚è¼¯
                if (maxProb < 0.3) {
                    lightResult = ACTIVITIES['æœªçŸ¥ç’°å¢ƒ'];
                } else if (topIndex >= 100 && topIndex < 300) {
                    lightResult = ACTIVITIES['æ˜äº®æˆ¶å¤–/é«˜å…‰'];
                } else if (topIndex >= 300 && topIndex < 700) {
                    lightResult = ACTIVITIES['å……è¶³å®¤å…§/ä¸­å…‰'];
                } else {
                    lightResult = ACTIVITIES['æ˜æš—å¤œæ™š/ä½å…‰'];
                }

                updateUI(lightResult, maxProb);
            });
            
            animationFrameId = requestAnimationFrame(predictLoop);
        }

        function updateUI(result, probability) {
            lightLevelElement.textContent = `${result.emoji} ${result.level}`;
            lightLevelElement.style.color = result.color;
            
            recommendationElement.innerHTML = 
                `<strong>æ¨è–¦æ´»å‹•:</strong> ${result.recommend} 
                 <br><span style="font-size: 0.8em; opacity: 0.7;"> (ä¿¡å¿ƒåº¦: ${Math.round(probability * 100)}%) </span>`;
        }

        // è³‡æºæ¸…ç†
        window.onbeforeunload = () => {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
            }
            if (model) {
                model.dispose();
            }
            tf.disposeVariables();
        };

    </script>
</body>
</html>
