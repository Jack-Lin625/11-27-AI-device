<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI èº²é¿è·‘é…·ï¼šå§¿å‹¢åˆ¤æ–·éŠæˆ²</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.14.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/movenet@1.0.0/dist/movenet.min.js"></script>

    <style>
        /* åŸºç¤æ¨£å¼å’Œä½ˆå±€ */
        body { 
            margin: 0; padding: 0; background-color: #000; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
            overflow: hidden; display: flex; flex-direction: column; align-items: center; 
            justify-content: center; height: 100vh;
        }
        #cam-container { 
            position: relative; width: 100%; height: 100%; display: flex; 
            justify-content: center; align-items: center; background: #111; 
        }
        video { 
            position: absolute; width: 100%; height: 100%; object-fit: cover; 
            /* é è¨­ä½¿ç”¨å‰ç½®é¡é ­ä¸¦æ°´å¹³ç¿»è½‰ï¼Œè®“ä½¿ç”¨è€…çœ‹èµ·ä¾†åƒé¡å­ */
            transform: scaleX(-1);
        }
        /* Canvas ç”¨æ–¼ç¹ªè£½é—œéµé»å’ŒéŠæˆ²å…ƒç´ ï¼Œå¿…é ˆèˆ‡ Video é‡ç–Š */
        #canvas {
            position: absolute; width: 100%; height: 100%; object-fit: cover;
            transform: scaleX(-1); /* é…åˆ Video ç¿»è½‰ */
            z-index: 5;
        }

        /* ä»‹é¢è¦†è“‹å±¤ */
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 10; pointer-events: none; display: flex; flex-direction: column; 
            justify-content: space-between; padding: 20px; box-sizing: border-box; 
        }
        .status-bar { 
            background: rgba(0, 0, 0, 0.6); color: #00ffcc; padding: 10px 15px; 
            border-radius: 20px; font-size: 14px; backdrop-filter: blur(5px); 
            align-self: flex-start; pointer-events: auto; margin-top: 10px; line-height: 1.6; 
        }
        
        /* éŠæˆ²æç¤ºå’Œåˆ†æ•¸å€ */
        #game-info { 
            background: rgba(0, 0, 0, 0.7); color: white; padding: 20px; border-radius: 15px; 
            align-self: center; margin-bottom: 50px; width: 90%; max-width: 400px; 
            text-align: center; pointer-events: auto; 
        }
        #current-action { 
            font-size: 2.2em; font-weight: bold; color: #FFC107; margin-bottom: 10px; 
            min-height: 1.2em; /* é¿å…æ–‡å­—è·³å‹• */
        }
        #score-display { 
            font-size: 1.2em; color: #B3E5FC; 
        }

        /* å•Ÿå‹•ç•«é¢ */
        #start-screen { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0, 0, 0, 0.9); z-index: 20; display: flex; 
            flex-direction: column; justify-content: center; align-items: center; 
            text-align: center; color: white; 
        }
        button { 
            background: #007aff; color: white; border: none; padding: 15px 40px; 
            font-size: 18px; border-radius: 30px; cursor: pointer; margin-top: 20px; 
            font-weight: bold; box-shadow: 0 4px 15px rgba(0,122,255,0.4); transition: transform 0.2s; 
        }
        button:active { transform: scale(0.95); }
        button:disabled { background: #555; color: #888; cursor: not-allowed; box-shadow: none; }
        .loader { 
            border: 4px solid #f3f3f3; border-top: 4px solid #00ffcc; border-radius: 50%; 
            width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 20px; 
            display: none; 
        }
        @keyframes spin { 
            0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } 
        }
    </style>
</head>
<body>

    <div id="cam-container">
        <video id="video" playsinline muted autoplay></video>
        <canvas id="canvas"></canvas>
    </div>

    <div id="ui-layer">
        <div class="status-bar" id="status">ç­‰å¾…å•Ÿå‹•...</div>
        
        <div id="game-info">
            <div id="current-action">æº–å‚™å°±ç·’</div>
            <div id="score-display">åˆ†æ•¸: 0 | å§¿å‹¢: ç«™ç«‹</div>
        </div>
    </div>

    <div id="start-screen">
        <div class="loader" id="loader"></div>
        <h2 id="loading-text">AI èº²é¿è·‘é…·ï¼šæ¨¡å‹æº–å‚™ä¸­</h2>
        <p id="info-text" style="font-size: 0.9em; color: #aaa; margin: 0 20px;">
            **ã€é‡è¦ã€‘** æœ¬éŠæˆ²éœ€ä½¿ç”¨å‰ç½®é¡é ­ã€‚<br>
            **ã€é›¢ç·šæ©Ÿåˆ¶ã€‘** é¦–æ¬¡é€£ç·šä¸‹è¼‰å®Œæ¨¡å‹å¾Œï¼Œå³å¯å®Œå…¨é›¢ç·šéŠç©ã€‚
        </p>
        <button id="btn-start" disabled>é–‹å§‹éŠæˆ² (è¼‰å…¥ä¸­)</button>
    </div>

    <script>
        // DOM å…ƒç´ 
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const btnStart = document.getElementById('btn-start');
        const statusText = document.getElementById('status');
        const startScreen = document.getElementById('start-screen');
        const loader = document.getElementById('loader');
        const loadingText = document.getElementById('loading-text');
        const infoText = document.getElementById('info-text');
        const currentActionElement = document.getElementById('current-action');
        const scoreDisplayElement = document.getElementById('score-display');

        // éŠæˆ²èˆ‡ AI ç‹€æ…‹
        let model = undefined;
        let animationFrameId = null;
        let score = 0;
        let currentPose = 'ç«™ç«‹'; // ç«™ç«‹, è·³èº, è¹²ä¸‹
        
        // å§¿å‹¢åˆ¤æ–·åƒæ•¸
        let lastHeadY = 0; // è¿½è¹¤é ­éƒ¨ Y åº§æ¨™
        const POSE_THRESHOLD = 0.05; // Y è»¸è®ŠåŒ–å¹…åº¦é–¾å€¼ (ç›¸å°æ–¼ç•«é¢é«˜åº¦çš„ 5%)
        const KNEE_MIN_SCORE = 0.5; // è†è“‹é—œéµé»çš„æœ€ä½ä¿¡å¿ƒåº¦
        const HEAD_INDEX = 0; // MoveNet é—œéµé»ç´¢å¼•ï¼šé¼»å­
        const LEFT_KNEE_INDEX = 13;
        const RIGHT_KNEE_INDEX = 14;

        // éŠæˆ²ç‰©ä»¶åƒæ•¸
        let obstacle = null;
        const OBSTACLE_SPEED = 0.005; // ç•«é¢å¯¬åº¦çš„æ¯”ä¾‹
        let gameRunning = false;

        // 1. åˆå§‹åŒ–
        window.onload = async () => {
            if (typeof tf === 'undefined') {
                loadingText.textContent = "âŒ éŒ¯èª¤ï¼šTensorFlow.js æ ¸å¿ƒå‡½å¼åº«è¼‰å…¥å¤±æ•—ï¼";
                infoText.innerHTML = "è«‹æª¢æŸ¥æ‚¨çš„ç¶²è·¯é€£ç·šæˆ–ç€è¦½å™¨æ”¯æ´ã€‚";
                return; 
            }
            btnStart.addEventListener('click', startGame);
            await loadModelAndSetupCamera();
        }

        // 2. è¼‰å…¥æ¨¡å‹å’Œç›¸æ©Ÿ
        async function loadModelAndSetupCamera() {
            loadingText.textContent = "AI æ¨¡å‹ä¸‹è¼‰ä¸­ (MoveNet - ç´„ 25 MB)...";
            loader.style.display = 'block';

            try {
                // A. è¼‰å…¥ MoveNet æ¨¡å‹ï¼ˆLightning ç‰ˆæœ¬ï¼Œé€Ÿåº¦æ›´å¿«ï¼‰
                model = await movenet.load(movenet.modelType.SINGLEPOSE_LIGHTNING);
                
                loadingText.textContent = "æ¨¡å‹è¼‰å…¥å®Œæˆï¼æ­£åœ¨å•Ÿå‹•ç›¸æ©Ÿ...";
                infoText.innerHTML = "è«‹å…è¨±ç›¸æ©Ÿæ¬Šé™ï¼Œæˆ‘å€‘å°‡ä½¿ç”¨å‰ç½®é¡é ­ã€‚";
                
                // B. å•Ÿå‹•ç›¸æ©Ÿ (ä½¿ç”¨å‰ç½®é¡é ­: user)
                const cameraSuccess = await setupCamera();
                if (!cameraSuccess) return; 

                loadingText.textContent = "âœ… ç›¸æ©Ÿå°±ç·’ï¼";
                infoText.innerHTML = "AI å·²æº–å‚™å¥½ **é›¢ç·šæ¨è«–**ã€‚é»æ“Šé–‹å§‹éŠæˆ²ã€‚";
                btnStart.disabled = false;
                btnStart.innerText = "ğŸš€ é–‹å§‹éŠæˆ² (é›¢ç·š)";

            } catch (error) {
                console.error('æ¨¡å‹è¼‰å…¥æˆ–åˆå§‹åŒ–å¤±æ•—:', error);
                loadingText.textContent = `âŒ è¼‰å…¥å¤±æ•—ï¼`;
                infoText.innerHTML = `è«‹æª¢æŸ¥ç¶²è·¯é€£ç·šï¼Œç¢ºä¿æ¨¡å‹æª”æ¡ˆèƒ½å¤ é¦–æ¬¡ä¸‹è¼‰ã€‚`;
                loader.style.display = 'none';
            }
        }

        // 3. è¨­å®šç›¸æ©Ÿ (ä½¿ç”¨å‰ç½®é¡é ­)
        async function setupCamera() {
            const constraints = {
                audio: false,
                video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } }
            };
            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        resizeCanvas();
                        window.addEventListener('resize', resizeCanvas);
                        resolve(true);
                    };
                });
            } catch (e) {
                loadingText.textContent = `âŒ ç›¸æ©Ÿæ¬Šé™è¢«æ‹’çµ•ï¼`;
                infoText.innerHTML = `è«‹å…è¨±ç€è¦½å™¨ä½¿ç”¨ç›¸æ©Ÿæ¬Šé™æ‰èƒ½é€²è¡ŒéŠæˆ²ã€‚`;
                btnStart.disabled = true;
                return false;
            }
        }

        function resizeCanvas() {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
        }
        
        // 4. éŠæˆ²å•Ÿå‹•èˆ‡å¾ªç’°
        function startGame() {
            startScreen.style.display = 'none';
            statusText.textContent = 'ğŸš€ éŠæˆ²é–‹å§‹ï¼AI å§¿å‹¢åµæ¸¬ä¸­...';
            btnStart.textContent = 'â¸ æš«åœéŠæˆ²'; // é€™è£¡æˆ‘å€‘åªåœ¨é–‹å§‹ç•«é¢ä½¿ç”¨æŒ‰éˆ•
            
            score = 0;
            currentActionElement.textContent = 'ä¿æŒç«™ç«‹';
            gameRunning = true;
            generateNewObstacle(); // ç”¢ç”Ÿç¬¬ä¸€å€‹éšœç¤™ç‰©
            
            predictLoop();
        }

        function generateNewObstacle() {
            const type = Math.random() > 0.5 ? 'low' : 'high';
            obstacle = {
                x: canvas.width, // å¾æœ€å³é‚Šé–‹å§‹
                y: type === 'low' ? canvas.height * 0.7 : canvas.height * 0.5, // è¹²ä¸‹æˆ–è·³èºé«˜åº¦
                width: canvas.width * 0.05,
                height: canvas.height * 0.1,
                type: type, // 'low' (éœ€è·³èº) æˆ– 'high' (éœ€è¹²ä¸‹)
                passed: false // æ˜¯å¦å·²é€šé
            };
            if (type === 'low') {
                currentActionElement.textContent = 'â¬‡ï¸ è·³èºï¼(èº²é¿ä½éšœç¤™)';
                currentActionElement.style.color = '#FF4500';
            } else {
                currentActionElement.textContent = 'â¬‡ï¸ è¹²ä¸‹ï¼(èº²é¿é«˜éšœç¤™)';
                currentActionElement.style.color = '#1E90FF';
            }
        }

        // 5. æ ¸å¿ƒéŠæˆ²èˆ‡ AI æ¨è«–å¾ªç’°
        async function predictLoop() {
            if (!model || video.readyState < 2 || !gameRunning) {
                animationFrameId = requestAnimationFrame(predictLoop);
                return;
            }

            // **æ ¸å¿ƒé›¢ç·šæ¨è«–**
            const poses = await model.estimatePoses(video, {
                flipHorizontal: false, // ç•«é¢å·²åœ¨ CSS ä¸­ç¿»è½‰ï¼Œé€™è£¡ä¸éœ€å†ç¿»è½‰
                maxPoses: 1,
                scoreThreshold: 0.3
            });

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (poses.length > 0) {
                const pose = poses[0];
                // åŸ·è¡Œå§¿å‹¢åˆ¤æ–·
                currentPose = checkPose(pose);
                
                // åŸ·è¡ŒéŠæˆ²é‚è¼¯
                updateGame(pose);

                // ç¹ªè£½é—œéµé» (å¯é¸ï¼Œç”¨æ–¼è¦–è¦ºåŒ–åµæ¸¬æ•ˆæœ)
                drawKeypoints(pose.keypoints);
            } else {
                currentPose = 'ç„¡æ³•åµæ¸¬';
            }
            
            scoreDisplayElement.innerHTML = `åˆ†æ•¸: **${score}** | å§¿å‹¢: ${currentPose}`;
            
            animationFrameId = requestAnimationFrame(predictLoop);
        }
        
        // 6. å§¿å‹¢åˆ¤æ–·é‚è¼¯
        function checkPose(pose) {
            const keypoints = pose.keypoints;
            const nose = keypoints[HEAD_INDEX];
            const leftKnee = keypoints[LEFT_KNEE_INDEX];
            const rightKnee = keypoints[RIGHT_KNEE_INDEX];

            // æ­¸ä¸€åŒ– Y è»¸ä½ç½® (0åˆ°1)
            const normalizedY = nose.y / canvas.height; 
            
            // è¹²ä¸‹åˆ¤æ–·ï¼šè†è“‹å¯è¦‹ä¸”é ­éƒ¨ Y è»¸ä¸‹é™
            const kneesVisible = (leftKnee.score > KNEE_MIN_SCORE && rightKnee.score > KNEE_MIN_SCORE);
            
            // åˆå§‹ç‹€æ…‹æª¢æŸ¥
            if (lastHeadY === 0) {
                lastHeadY = normalizedY;
                return 'ç«™ç«‹';
            }

            const y_diff = normalizedY - lastHeadY; // Y è»¸è¶Šå¾€ä¸‹ï¼Œæ•¸å­—è¶Šå¤§
            
            let poseResult = 'ç«™ç«‹';
            
            // åˆ¤æ–·å‹•ä½œ
            if (y_diff > POSE_THRESHOLD) {
                // é ­éƒ¨å¾€ä¸‹ç§»å‹• (æ•¸å­—è®Šå¤§)
                poseResult = 'è¹²ä¸‹';
            } else if (y_diff < -POSE_THRESHOLD * 2) { 
                // è·³èºé€šå¸¸è®ŠåŒ–æ›´å¤§ï¼Œæ‰€ä»¥é–¾å€¼è¨­é«˜ä¸€é»
                poseResult = 'è·³èº';
            } else {
                poseResult = 'ç«™ç«‹';
            }
            
            // æ›´æ–°ä¸Šä¸€æ¬¡çš„ä½ç½®
            // é€™è£¡ä½¿ç”¨åŠ æ¬Šå¹³å‡ä¾†å¹³æ»‘ä½ç½®ï¼Œæ¸›å°‘æŠ–å‹•
            lastHeadY = lastHeadY * 0.8 + normalizedY * 0.2; 
            
            return poseResult;
        }

        // 7. éŠæˆ²é‚è¼¯èˆ‡ç¢°æ’åµæ¸¬
        function updateGame(pose) {
            if (!obstacle) return;
            
            // ç§»å‹•éšœç¤™ç‰©
            obstacle.x -= canvas.width * OBSTACLE_SPEED;

            // ç¢°æ’åµæ¸¬è®Šæ•¸ (ä½¿ç”¨é ­éƒ¨ Y åº§æ¨™ä½œç‚ºåˆ¤æ–·ä¾æ“š)
            const headY = pose.keypoints[HEAD_INDEX].y; 

            // ç¹ªè£½éšœç¤™ç‰©
            ctx.fillStyle = obstacle.type === 'low' ? 'red' : 'blue';
            ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);

            // éšœç¤™ç‰©é€šéç•«é¢
            if (obstacle.x + obstacle.width < 0) {
                score++;
                generateNewObstacle();
                return;
            }
            
            // ç¢°æ’åµæ¸¬å€é–“ (ç‰©é«”åˆ°é”äººç‰©æ‰€åœ¨ä½ç½®)
            const collisionZoneStart = canvas.width * 0.4;
            const collisionZoneEnd = canvas.width * 0.6;
            
            if (obstacle.x > collisionZoneStart && obstacle.x < collisionZoneEnd) {
                let hit = false;
                
                if (obstacle.type === 'low') {
                    // ä½éšœç¤™ç‰© (éœ€è·³èº)
                    // å¦‚æœé ­éƒ¨Yåº§æ¨™ä½æ–¼éšœç¤™ç‰©åº•éƒ¨ (å³æ²’æœ‰è·³èµ·ä¾†)ï¼Œå‰‡åˆ¤æ–·ç‚ºæ’åˆ°
                    if (headY > obstacle.y + obstacle.height / 2) { 
                        if (currentPose !== 'è·³èº') hit = true;
                    }

                } else {
                    // é«˜éšœç¤™ç‰© (éœ€è¹²ä¸‹)
                    // å¦‚æœé ­éƒ¨Yåº§æ¨™é«˜æ–¼éšœç¤™ç‰©é ‚éƒ¨ (å³æ²’æœ‰è¹²ä¸‹)ï¼Œå‰‡åˆ¤æ–·ç‚ºæ’åˆ°
                    if (headY < obstacle.y + obstacle.height / 2) {
                        if (currentPose !== 'è¹²ä¸‹') hit = true;
                    }
                }

                if (hit) {
                    gameRunning = false;
                    currentActionElement.textContent = `ğŸ’¥ éŠæˆ²çµæŸï¼å¾—åˆ†: ${score}`;
                    currentActionElement.style.color = 'red';
                    // é€™è£¡å¯ä»¥åŠ å…¥é‡æ–°é–‹å§‹æŒ‰éˆ•
                }
            }
            
        }

        // 8. ç¹ªè£½é—œéµé»ï¼ˆç”¨æ–¼é™¤éŒ¯å’Œè¦–è¦ºåŒ–ï¼‰
        function drawKeypoints(keypoints) {
            ctx.fillStyle = "#FF00FF";
            keypoints.forEach(keypoint => {
                if (keypoint.score > 0.4) {
                    ctx.beginPath();
                    ctx.arc(keypoint.x, keypoint.y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
            // ç¹ªè£½é ­éƒ¨ä½ç½®çš„åƒè€ƒç·š
            ctx.strokeStyle = '#00FFFF';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, lastHeadY * canvas.height);
            ctx.lineTo(canvas.width, lastHeadY * canvas.height);
            ctx.stroke();
        }


        // 9. è³‡æºæ¸…ç†
        window.onbeforeunload = () => {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
            }
            if (model) {
                // é‡‹æ”¾ MoveNet ä½”ç”¨çš„è³‡æº
                model.dispose(); 
            }
            tf.disposeVariables();
        };

    </script>
</body>
</html>
